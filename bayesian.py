# -*- coding: utf-8 -*-
"""Bayesian.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tk3MZugQrjjUzkSUsq0n1zl3aRdCxI-y
"""

import scipy.io as scio
import numpy as np
from math import pi,sqrt,exp,pow
#read the training and label file
training_file = '/content/drive/MyDrive/Colab Notebooks/ml_ca/Data_Train.mat'
training_dict = scio.loadmat(training_file)
training_data = training_dict["Data_Train"]

label_file = '/content/drive/MyDrive/Colab Notebooks/ml_ca/Label_Train.mat'
label_dict = scio.loadmat(label_file)
label = label_dict["Label_Train"]

test_file = '/content/drive/MyDrive/Colab Notebooks/ml_ca/Data_test.mat'
test_dict = scio.loadmat(test_file)
test_data = test_dict["Data_test"]

#classify the training data to 3 classes
c1 = []
c2 = []
c3 = []
for i in range(len(training_data)):
  if label[i] == 1:
    c1.append(list(training_data[i]))
  elif label[i] == 2:
    c2.append(list(training_data[i]))
  elif label[i] == 3:
    c3.append(list(training_data[i]))
c1 = np.array(c1)
c2 = np.array(c2)
c3 = np.array(c3)

#calculate the miu and sigma
#calculate the miu
def cal_miu(c):
  sum_x = [0]
  for x_k in c:
    sum_x += x_k
  miu = sum_x/len(c)
  return miu

miu_1 = cal_miu(c1)
miu_2 = cal_miu(c2)
miu_3 = cal_miu(c3)

#calculate the sigma
def cal_sigma(c,miu):
  sum_covariance = [0]
  for x_k in c:
    a = np.array([x_k-miu])
    sum_covariance += np.dot(a.T,a)
  covariance = sum_covariance/len(c)
  return covariance

covariance_1 = cal_sigma(c1,miu_1)
covariance_2 = cal_sigma(c2,miu_2)
covariance_3 = cal_sigma(c3,miu_3)

#calculate conditional_prob
def cond_prob(covariance,x_k,miu,d=4):
  det_sigma = np.linalg.det(covariance)
  inv_cov = np.linalg.pinv(covariance)
  prob = 1/(pow(2*pi,d/2)*sqrt(det_sigma))
  a = np.dot((x_k-miu),inv_cov)
  a = np.dot(a,(x_k-miu).T)
  prob = prob*exp(-0.5*a)
  return prob

x_k = np.array([1,2,3,4])
cond_prob(covariance_3,x_k,miu_3)

#calculate prior_prob
def prior_prob(c,training_data = training_data):
  return len(c)/len(training_data)

p_w1 = prior_prob(c1,training_data)
p_w2 = prior_prob(c2,training_data)
p_w3 = prior_prob(c3,training_data)

#get discriminant function
def g_x(x_k,c):
  miu = cal_miu(c)
  covariance = cal_sigma(c,miu)
  cond_pro = cond_prob(covariance,x_k,miu)
  prior_pro = prior_prob(c)
  return cond_pro*prior_pro

#try on the training set
def test(dataset,label):
  correct = 0
  result = []
  for i in range(len(dataset)):
    x_k = dataset[i]
    g1_x = g_x(x_k,c1)
    g2_x = g_x(x_k,c2)
    g3_x = g_x(x_k,c3)
    if g1_x >= g2_x and g1_x >= g3_x:
      result.append([1])
    elif g2_x >= g1_x and g2_x >= g3_x:
      result.append([2])
    elif g3_x >= g1_x and g3_x >= g2_x:
      result.append([3])
  label = list(label)
  for i in range(len(result)):
    if result[i] == label[i]:
      correct+=1
  accuracy = correct/len(dataset)
  return accuracy

accuracy = test(training_data,label)
print("The prediction accuracy on the training dataset = %.2f%%" %(accuracy*100))

#inference on the test_dataset
def predict(dataset):
  result = []
  for i in range(len(dataset)):
    x_k = dataset[i]
    g1_x = g_x(x_k,c1)
    g2_x = g_x(x_k,c2)
    g3_x = g_x(x_k,c3)
    if g1_x >= g2_x and g1_x >= g3_x:
      result.append([1])
    elif g2_x >= g1_x and g2_x >= g3_x:
      result.append([2])
    elif g3_x >= g1_x and g3_x >= g2_x:
      result.append([3])
  return result
pred = predict(test_data)
print(pred)

#save the predction result of test dataset
pred=np.array(pred)
np.savetxt("/content/drive/MyDrive/Colab Notebooks/ml_ca/pred_Bayesian.csv",pred,fmt="%i")